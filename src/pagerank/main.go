package main

import (
	mr "mapreduce"
)

// The mapping function is called once for each piece of the input. In this
// framework, the key is the name of the file that is being processed, and the
// value is the file's contents. The return value should be a slice of key/value
// pairs, each represented by a mapreduce.KeyValue.
func mapF(fileName string, contents string) (res []mr.KeyValue) {
	// TODO: Implement me for extra credit.

	return
}

// The reduce function is called once for each key generated by Map, with a list
// of that key's string value (merged across all inputs). The return value
// should be a single output value for that key.
func reduceF(key string, values []string) string {
	// TODO: Implement me for extra credit.

	return ""
}

// Parses the command line arguments and runs the computation.
func main() {
	// TODO: Implement this function for Page Rank. You won't be able to use
	// `run` directly here since you'll need to iterative compute the page rank.
	// See mr/parse_cmd_line.go for an example on how to use the library
	// directly. Ignore the node type: you can choose what you do.

	// Some useful code, to get started:
	// jobName := "pagerank"
	// numIterations := 10
	// _, reducers, inputFileNames := mr.ParseCmdLine()
}
