# MapReduce
### How to use: (wordcount example)

1. import (mr "mapreduce")
```go
  import mr "mapreduce"
```

2. Customize map function. The mapping function is called once for each piece of the input. In this framework, the key is the name of the file that is being processed, and the value is the file's contents. The return value should be a slice of key/value pairs, each represented by a mapreduce.KeyValue.
```go 
  func mapF(fileName string, contents string) (res []mr.KeyValue) {
     words := strings.FieldsFunc(contents, func(c rune) bool { return !unicode.IsLetter(c) })
     wordCount := make(map[string]int)

     for _, word := range words {
         wordCount[word]++
     }

     for word, count := range wordCount {
         res = append(res, mr.KeyValue{word, strconv.Itoa(count)})
     }
     return
 }
```

3. Customize reduce funciton. The reduce function is called once for each key generated by Map, with a list of that key's string value (merged across all inputs). The return value should be a single output value for that key.

```go 
  func reduceF(key string, values []string) string {
     var count int64
     for _, value := range values {
         x, err := strconv.ParseInt(value, 10, 64)
         if err != nil {
             fmt.Errorf("Failed parsed integer: %s\n", value)
             continue
         }
         count += x
     }
     return strconv.FormatInt(count, 10)
 }
```


4. Run with mapF and reduceF:
```go
  mr.Run("wordcount", mapF, reduceF)
```


###Acknowledgement
Skeleton code credit to [Sergio](https://sergio.bz) from CS240 @ Stanford. 
